#!/usr/bin/env ruby
# frozen_string_literal: true

def clear_screen
  puts "\e[H\e[2J"
end

def get_user_choice(list)
  list.each_with_index do |elem, i|
    puts "#{i + 1}: #{elem}"
  end
  print 'Enter number or press ^C to exit> '
  begin
    (Integer(gets) - 1)
  rescue StandardError
    false
  end
end

def choose_from_list(list, names)
  clear_screen
  user_selection = false
  begin
    until user_selection
      user_selection = get_user_choice(names)
      puts 'Invalid selection, please try again.' if user_selection && !list[user_selection]
    end

    list[user_selection]
  rescue Interrupt
    nil
  end
end

# Radio: the base radio class
class Radio
  def initialize
    if system('command -v mpc 1>/dev/null 2>&1')
      @player = 'mpc'
    elsif system('command -v mpv 1>/dev/null 2>&1')
      @player = 'mpv'
    else
      warn 'neither mpc nor mpv installed.'
      exit 1
    end
  end

  # Queuing handled by subclass
  def play(stream)
    if @player == 'mpc'
      system 'mpc', 'play'
    else
      clear_screen
      puts "Loading #{stream}..."
      system 'mpv', stream, '--vid=no', '--volume=50'
    end
  end
end

# SomaFM radio subclass
class SomaFM < Radio
  def initialize(selected_channel)
    super()
    @channel = selected_channel[:link]
  end

  def play
    if @player == 'mpc'
      system 'mpc', 'clear'
      system('mpc', 'load', @channel)
    end
    super @channel
  end
end

# Radios with a direct stream link
class OtherRadio < Radio
  def initialize(selected_channel)
    super()
    @channel = selected_channel[:link]
  end

  def play
    if @player == 'mpc'
      system 'mpc', 'clear'
      system 'mpc', 'add', @channel
    end
    super @channel
  end
end

# RadioGarden global radios
class RadioGarden < Radio
  require 'json'
  require 'open-uri'
  require 'cgi'

  def initialize(_)
    retrieved_channels = []
    @base_url = 'https://radio.garden/api'
    while retrieved_channels.empty?
      print 'Enter radio search: '
      query = gets.chomp
      begin
        URI.parse("#{@base_url}/search?q=#{CGI.escape query}").open do |response|
          retrieved_channels = JSON.parse(response.read)['hits']['hits']
        end
      rescue OpenURI::HTTPError
        retrieved_channels = []
      end

      channels = []
      retrieved_channels.each do |c|
        channels << { name: "#{c['_source']['title']} (#{c['_source']['subtitle']})",
                      id: c['_source']['channelId'] }
      end
    end

    selected_channel = choose_from_list(channels, channels.map { |c| c[:name] })

    begin
      # Will redirect
      @channel = URI.parse("#{@base_url}/ara/content/listen/#{selected_channel[:id]}/channel.mp3").open(redirect: false)
    rescue OpenURI::HTTPRedirect => e
      @channel = e.uri.to_s.gsub(/\?listening-from.*/, '')
    rescue OpenURI::HTTPError
      @channel = None
    end
    super()
  end

  def play
    if @player == 'mpc'
      system 'mpc', 'clear'
      system 'mpc', 'add', @channel
    end
    super @channel
  end
end

# Play music from a subreddit
class Subreddit < Radio
  require 'json'
  require 'open-uri'
  require 'shellwords'

  def initialize(_)
    posts = []
    while posts.empty?
      print 'Enter subreddit name: '
      sub = gets.chomp
      url = "https://www.reddit.com/r/#{sub}/top.json?t=month&limit=100&show=all"
      begin
        URI.parse(url).open('User-Agent' => 'ruby/2.7', 'Accept' => 'application/json') do |response|
          data = JSON.parse(response.read)['data']
          posts = data['children']
        end
      rescue OpenURI::HTTPError
        posts = []
      end
      puts 'Subreddit has no music posts or does not exist.' if posts.empty?
    end
    @links = []
    posts.each do |post|
      p = post['data']
      if !p['is_self'] && p['post_hint'] != 'image'
        @links.append(title: p['title'], url: p['url'], reddit: "https://reddit.com#{p['permalink']}")
      end
    end

    super()
  end

  def play
    puts "Number of tracks: #{@links.length}"

    # TODO: support mpd
    system("mpv --vid=no --volume=50 -- #{@links.map { |l| l[:url] }.shelljoin}")
  rescue Interrupt
    true
  end
end


# TODO: read some URLs from config file
channels = [
  { name: 'SOMA - Groove Salad (ambient/downtempo)', link: 'https://somafm.com/groovesalad256.pls', radio: SomaFM },
  { name: 'SOMA - Mission Control (ambient, space)', link: 'https://somafm.com/missioncontrol.pls', radio: SomaFM },
  { name: 'SOMA - The Trip (prog house/trance)', link: 'https://somafm.com/thetrip.pls', radio: SomaFM },
  { name: 'SOMA - Beat Blender (deep house, downtempo)', link: 'https://somafm.com/beatblender.pls', radio: SomaFM },
  { name: 'SOMA - Dub Step', link: 'https://somafm.com/dubstep256.pls', radio: SomaFM },
  { name: 'SOMA - Defcon', link: 'https://somafm.com/defcon256.pls', radio: SomaFM },
  { name: 'SOMA - Deep Space (deep ambient electro/experimental)', link: 'https://somafm.com/deepspaceone.pls',
    radio: SomaFM },
  { name: 'SOMA - Thistle Radio (Celtic)', link: 'https://somafm.com/thistle.pls', radio: SomaFM },
  { name: 'SOMA - Fluid (instr. hip hop, liquid trap)', link: 'https://somafm.com/fluid.pls, radio: SomaFM }' },
  { name: 'Psystation: Classic Goa', link: 'http://hestia2.cdnstream.com/1458_128', radio: OtherRadio },
  { name: 'Psystation: Prog Psytrance', link: 'http://hestia2.cdnstream.com/1453_128', radio: OtherRadio },
  { name: 'Nightride FM', link: 'https://nightride.fm/stream/nightride.m4a', radio: OtherRadio },
  { name: 'Nightwave Plaza', link: 'https://plaza.one/mp3', radio: OtherRadio },
  { name: '6forty', link: 'http://54.173.171.80:8000/6forty', radio: OtherRadio },
  { name: 'Fnoob Techno', link: 'http://play.fnoobtechno.com:2199/tunein/fnoobtechno320.pls', radio: OtherRadio },
  { name: 'RadioGarden', radio: RadioGarden },
  { name: 'Subreddit', radio: Subreddit }
]

selected_channel = choose_from_list(channels, channels.map { |c| c[:name] })
exit 0 if selected_channel.nil?
radio = selected_channel[:radio].new(selected_channel)
radio.play
